'use strict';

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const _ = require('lodash');
/**
 * Get the first truthy value returned by a mapper function
 * @param {any[]} arr
 * @param {function} fn
 */


function first(arr, fn) {
  const l = arr.length;

  for (let i = 0; i < l; i += 1) {
    const res = fn(arr[i], i);

    if (res) {
      return res;
    }
  }

  return null;
}

exports.first = first;

function matchPattern(tokens, input, end) {
  return first(tokens, Tok => {
    let matches;

    if (Tok.patterns) {
      matches = first(Tok.patterns, pattern => input.match(`^(?:${pattern})${end ? '$' : ''}`));
    } else {
      matches = input.match(`^(?:${Tok.pattern})${end ? '$' : ''}`);
    }

    return matches && [Tok, matches];
  });
}

exports.matchPattern = matchPattern;
/**
 * Split on commas, but ignore commas inside strings
 * @param {string} str
 */

function splitArgs(str) {
  const out = [];
  let inString = false;
  let currentArg = '';

  for (let index = 0; index < str.length; index += 1) {
    const c = str[index];

    if (c === ',' && !inString) {
      out.push(currentArg.trim());
      currentArg = '';
    } else if (currentArg.length === 0 && c === '"' && !inString) {
      currentArg += c;
      inString = true;
    } else if (inString && c === '"' && str[index - 1] !== '\\') {
      currentArg += c;
      inString = false;
    } else if (!(c === ' ' && currentArg.length === 0)) {
      currentArg += c;
    }
  }

  out.push(currentArg.trim());
  return out;
}

exports.splitArgs = splitArgs;

class Token {
  constructor() {
    this.tokenType = this.constructor.name;
  }

}

_defineProperty(Token, "priority", 0);

class Text extends Token {
  constructor(value) {
    super();
    this.value = value;
  }

}

class Expression extends Token {
  constructor(value) {
    super();
    const found = matchPattern(Expression.extensions, value, true);

    if (!found) {
      throw TypeError('Invalid arguments');
    }

    const [Extension, matches] = found;
    return new Extension(...matches);
  }

  static get pattern() {
    return _.flatMap(Expression.extensions, Ext => Ext.patterns || Ext.pattern).map(pattern => `(?:${pattern})`).join('|');
  }

}

_defineProperty(Expression, "extensions", []);

const unescapeMap = {
  '\\b': '\b',
  '\\t': '\t',
  '\\n': '\n',
  '\\v': '\v',
  '\\f': '\f',
  '\\r': '\r',
  '\\"': '"',
  '\\\'': '\'',
  '\\\\': '\\'
};

class StringLiteral extends Token {
  constructor(raw, rawValue) {
    super();
    const value = rawValue.replace(/\\(.)/g, (str, c) => unescapeMap[str] || c);
    Object.assign(this, {
      raw,
      rawValue,
      value
    });
  }

}

_defineProperty(StringLiteral, "pattern", '"((?:\\\\.|[^"\\n])*)"');

Expression.extensions.push(StringLiteral);

class SimpleExpression extends Token {
  constructor(path) {
    super();
    Object.assign(this, {
      path
    });
  }

}

_defineProperty(SimpleExpression, "pattern", '[@a-zA-Z0-9/._:\\-]+');

Expression.extensions.push(SimpleExpression);
const simpleOrString = `(?:${StringLiteral.pattern}|${SimpleExpression.pattern})`;

class HelperExpression extends Token {
  constructor(raw, helperName, args) {
    super();

    if (args) {
      const arr = splitArgs(args.replace(/^ *, */, '')).map(arg => new Expression(arg));
      Object.assign(this, {
        raw,
        helperName,
        args: arr
      });
    } else {
      Object.assign(this, {
        raw,
        helperName,
        args: []
      });
    }
  }

}

_defineProperty(HelperExpression, "patterns", [`function\\.(${SimpleExpression.pattern})((?: *, *${simpleOrString})*)`, `(${SimpleExpression.pattern})(?:\\( *(${simpleOrString}(?: *, *${simpleOrString})*)? *\\))`]);

Expression.extensions.push(HelperExpression);

class OpenIf extends Token {
  constructor(raw, not, test) {
    super();
    Object.assign(this, {
      raw,
      not: !!not,
      test: new Expression(test)
    });
  }

}

_defineProperty(OpenIf, "patterns", [`<!-- IF (!?)(${Expression.pattern}) -->`, `{{{ ?if (!?)(${Expression.pattern}) ?}}}`]);

_defineProperty(OpenIf, "priority", 60);

class OpenIter extends Token {
  constructor(raw, subject) {
    super();
    Object.assign(this, {
      raw,
      subject: new SimpleExpression(subject),
      name: subject.replace(/^[./]*/, ''),
      cleanName: subject.replace(/^[./]*/, '').replace(/(^[^a-zA-Z_])|[^a-zA-Z0-9_]/g, '_')
    });
  }

}

_defineProperty(OpenIter, "patterns", [`<!-- BEGIN (${SimpleExpression.pattern}) -->`, `{{{ ?each (${SimpleExpression.pattern}) ?}}}`]);

_defineProperty(OpenIter, "priority", 50);

class Else extends Token {}

_defineProperty(Else, "patterns", ['<!-- ELSE -->', '{{{ ?else ?}}}']);

_defineProperty(Else, "priority", 40);

class Close extends Token {
  constructor(raw) {
    super();
    Object.assign(this, {
      raw
    });
  }

}

_defineProperty(Close, "patterns", ['<!-- END(.*?) -->', '{{{ ?end ?}}}']);

_defineProperty(Close, "priority", 30);

class RawMustache extends Token {
  constructor(raw, expression) {
    super();
    Object.assign(this, {
      raw,
      expression: new Expression(expression)
    });
  }

}

_defineProperty(RawMustache, "pattern", `\\{\\{(${Expression.pattern})\\}\\}`);

_defineProperty(RawMustache, "priority", 20);

class EscapedMustache extends RawMustache {}

_defineProperty(EscapedMustache, "pattern", `\\{(${Expression.pattern})\\}`);

_defineProperty(EscapedMustache, "priority", 10);

const tokens = {
  Token,
  Text,
  StringLiteral,
  Expression,
  SimpleExpression,
  HelperExpression,
  OpenIf,
  OpenIter,
  Else,
  Close,
  RawMustache,
  EscapedMustache
};
exports.tokens = tokens;
//# sourceMappingURL=tokens.js.map
